---
title: "Next.js 14 App Router 완벽 가이드"
date: "2024-01-15"
description: "Next.js 14의 App Router를 사용하여 현대적인 웹 애플리케이션을 구축하는 방법을 알아봅니다."
tags: ["Next.js", "React", "App Router", "SSR"]
cover: "/images/posts/nextjs-14-guide.jpg"
draft: false
---

Next.js 14가 출시되면서 App Router가 안정화되었습니다. 이번 글에서는 App Router의 핵심 개념과 실제 프로젝트에서 활용하는 방법을 상세히 알아보겠습니다.

## App Router란?

App Router는 React Server Components를 기반으로 한 새로운 라우팅 시스템입니다. 기존의 Pages Router와 비교했을 때 다음과 같은 장점이 있습니다:

- **서버 컴포넌트 지원**: 기본적으로 서버에서 렌더링
- **중첩 라우팅**: 더 유연한 레이아웃 구성
- **스트리밍**: 점진적 페이지 로딩
- **향상된 데이터 패칭**: fetch API 확장

## 기본 구조

App Router에서는 `app` 디렉토리 내의 폴더 구조가 URL 경로가 됩니다:

```
app/
├── page.tsx          # / 
├── layout.tsx        # 루트 레이아웃
├── blog/
│   ├── page.tsx      # /blog
│   ├── layout.tsx    # 블로그 레이아웃
│   └── [slug]/
│       └── page.tsx  # /blog/[slug]
└── api/
    └── posts/
        └── route.ts  # API 라우트
```

<Note>
App Router에서는 `page.tsx` 파일이 있는 폴더만 라우트로 인식됩니다.
</Note>

## 서버 컴포넌트 활용

서버 컴포넌트는 서버에서 실행되어 HTML을 생성합니다. 데이터베이스 접근이나 파일 시스템 작업을 직접 수행할 수 있습니다:

```tsx
// app/posts/page.tsx
async function PostsPage() {
  // 서버에서 직접 데이터 패칭
  const posts = await fetch('https://api.example.com/posts')
    .then(res => res.json())

  return (
    <div>
      <h1>블로그 포스트</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  )
}

export default PostsPage
```

## 클라이언트 컴포넌트

상호작용이 필요한 컴포넌트는 `'use client'` 지시어를 사용합니다:

```tsx
'use client'

import { useState } from 'react'

function InteractiveButton() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(count + 1)}>
      클릭 횟수: {count}
    </button>
  )
}
```

<Warning>
클라이언트 컴포넌트는 필요한 경우에만 사용하세요. 서버 컴포넌트가 기본입니다.
</Warning>

## 레이아웃 시스템

App Router의 레이아웃은 중첩되어 적용됩니다:

```tsx
// app/layout.tsx (루트 레이아웃)
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ko">
      <body>
        <header>전역 헤더</header>
        <main>{children}</main>
        <footer>전역 푸터</footer>
      </body>
    </html>
  )
}

// app/blog/layout.tsx (블로그 레이아웃)
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="blog-layout">
      <aside>사이드바</aside>
      <div className="content">
        {children}
      </div>
    </div>
  )
}
```

## 데이터 패칭 패턴

### 1. fetch API 확장

```tsx
async function getData() {
  const res = await fetch('https://api.example.com/data', {
    // Next.js 확장 옵션
    next: { 
      revalidate: 60, // 60초마다 재검증
      tags: ['posts'] // 캐시 태그
    }
  })
  
  if (!res.ok) {
    throw new Error('데이터 패칭 실패')
  }
 
  return res.json()
}
```

### 2. 병렬 데이터 패칭

```tsx
async function PostPage({ params }: { params: { id: string } }) {
  // 병렬로 데이터 패칭
  const [post, comments] = await Promise.all([
    getPost(params.id),
    getComments(params.id)
  ])

  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
      <Comments data={comments} />
    </article>
  )
}
```

## 스트리밍과 로딩 UI

```tsx
// app/blog/loading.tsx
export default function Loading() {
  return (
    <div className="animate-pulse">
      <div className="h-8 bg-gray-200 rounded mb-4"></div>
      <div className="space-y-2">
        <div className="h-4 bg-gray-200 rounded"></div>
        <div className="h-4 bg-gray-200 rounded"></div>
      </div>
    </div>
  )
}

// Suspense를 이용한 부분적 스트리밍
import { Suspense } from 'react'

function PostPage() {
  return (
    <div>
      <h1>포스트 제목</h1>
      <Suspense fallback={<div>댓글 로딩 중...</div>}>
        <Comments />
      </Suspense>
    </div>
  )
}
```

## 메타데이터 생성

```tsx
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Next.js 14 가이드',
  description: 'App Router를 활용한 현대적인 웹 개발',
  openGraph: {
    title: 'Next.js 14 App Router 가이드',
    description: 'App Router를 활용한 현대적인 웹 개발',
    images: ['/og-image.jpg'],
  },
}

// 동적 메타데이터
export async function generateMetadata(
  { params }: { params: { slug: string } }
): Promise<Metadata> {
  const post = await getPost(params.slug)
 
  return {
    title: post.title,
    description: post.excerpt,
  }
}
```

## 최적화 팁

1. **서버 컴포넌트 우선 사용**: 클라이언트 컴포넌트는 꼭 필요한 경우에만
2. **적절한 캐싱 전략**: `revalidate`와 `tags` 활용
3. **스트리밍 활용**: 빠른 초기 로딩을 위해 Suspense 사용
4. **코드 분할**: 동적 임포트로 번들 크기 최적화

## 마무리

Next.js 14의 App Router는 강력하고 유연한 라우팅 시스템을 제공합니다. 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 조합하여 성능과 사용자 경험을 모두 챙길 수 있습니다.

다음 글에서는 App Router를 활용한 실제 프로젝트 구축 과정을 자세히 다뤄보겠습니다.

---

이 글이 도움이 되었다면 [Twitter](https://twitter.com/juyesu_dev)에서 공유해주세요!
