---
title: "React 성능 최적화: 실전 가이드"
date: "2023-12-22"
description: "React 애플리케이션의 성능을 향상시키는 다양한 기법들을 실제 사례와 함께 알아봅니다."
tags: ["React", "Performance", "Optimization", "JavaScript"]
cover: "/images/posts/react-performance.jpg"
draft: false
---

React 애플리케이션이 느려지는 이유는 다양합니다. 이번 글에서는 실제 프로젝트에서 겪을 수 있는 성능 문제들과 해결 방법을 살펴보겠습니다.

## 1. 불필요한 리렌더링 방지

### React.memo 활용

```jsx
// ❌ 부모가 리렌더링될 때마다 함께 리렌더링
const UserCard = ({ user, onEdit }) => {
  console.log('UserCard 렌더링:', user.name)
  
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>편집</button>
    </div>
  )
}

// ✅ props가 변경되지 않으면 리렌더링 건너뛰기
const UserCard = React.memo(({ user, onEdit }) => {
  console.log('UserCard 렌더링:', user.name)
  
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>편집</button>
    </div>
  )
})
```

### useCallback으로 함수 메모이제이션

```jsx
const UserList = () => {
  const [users, setUsers] = useState([])
  const [filter, setFilter] = useState('')

  // ❌ 매번 새로운 함수가 생성됨
  const handleEdit = (userId) => {
    // 편집 로직
  }

  // ✅ 함수를 메모이제이션
  const handleEdit = useCallback((userId) => {
    // 편집 로직
  }, [])

  // ✅ 의존성이 있는 경우
  const handleDelete = useCallback((userId) => {
    setUsers(users.filter(u => u.id !== userId))
  }, [users])

  return (
    <div>
      {users.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  )
}
```

<Note>
useCallback은 함수의 참조를 메모이제이션하지만, 함수 내부 로직은 여전히 실행됩니다. 의존성 배열을 정확히 관리하는 것이 중요합니다.
</Note>

## 2. useMemo로 계산 비용 줄이기

```jsx
const ExpensiveComponent = ({ items, filter }) => {
  // ❌ 매 렌더링마다 비싼 계산 수행
  const expensiveValue = items
    .filter(item => item.category === filter)
    .reduce((sum, item) => sum + item.price, 0)

  // ✅ 의존성이 변경될 때만 계산
  const expensiveValue = useMemo(() => {
    console.log('비싼 계산 수행...')
    return items
      .filter(item => item.category === filter)
      .reduce((sum, item) => sum + item.price, 0)
  }, [items, filter])

  return <div>총 가격: {expensiveValue}</div>
}
```

## 3. 가상화로 대용량 리스트 최적화

```jsx
import { FixedSizeList as List } from 'react-window'

const VirtualizedList = ({ items }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <UserCard user={items[index]} />
    </div>
  )

  return (
    <List
      height={600}        // 컨테이너 높이
      itemCount={items.length}
      itemSize={80}       // 각 아이템 높이
      width="100%"
    >
      {Row}
    </List>
  )
}

// 수천 개의 아이템도 부드럽게 렌더링
<VirtualizedList items={thousandsOfUsers} />
```

## 4. 코드 분할로 초기 로딩 시간 단축

```jsx
import { lazy, Suspense } from 'react'

// ✅ 필요할 때만 로드
const AdminPanel = lazy(() => import('./AdminPanel'))
const UserSettings = lazy(() => import('./UserSettings'))

const App = () => {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route 
          path="/admin" 
          element={
            <Suspense fallback={<div>관리자 패널 로딩...</div>}>
              <AdminPanel />
            </Suspense>
          } 
        />
        <Route 
          path="/settings" 
          element={
            <Suspense fallback={<div>설정 로딩...</div>}>
              <UserSettings />
            </Suspense>
          } 
        />
      </Routes>
    </Router>
  )
}
```

## 5. 이미지 최적화

```jsx
import Image from 'next/image'

const OptimizedImage = () => {
  return (
    <>
      {/* ❌ 브라우저가 모든 이미지를 즉시 로드 */}
      <img src="/large-image.jpg" alt="큰 이미지" />
      
      {/* ✅ 지연 로딩과 최적화 */}
      <Image
        src="/large-image.jpg"
        alt="큰 이미지"
        width={800}
        height={600}
        placeholder="blur"
        blurDataURL="data:image/jpeg;base64,..."
        loading="lazy"
      />
      
      {/* ✅ 네이티브 lazy loading */}
      <img 
        src="/image.jpg" 
        alt="이미지" 
        loading="lazy"
        decoding="async"
      />
    </>
  )
}
```

## 6. 상태 관리 최적화

```jsx
// ❌ 하나의 큰 상태 객체
const [appState, setAppState] = useState({
  user: null,
  posts: [],
  comments: [],
  ui: {
    loading: false,
    error: null
  }
})

// ✅ 관심사별로 상태 분리
const [user, setUser] = useState(null)
const [posts, setPosts] = useState([])
const [comments, setComments] = useState([])
const [loading, setLoading] = useState(false)
const [error, setError] = useState(null)

// ✅ Context 세분화
const UserContext = createContext()
const PostsContext = createContext()
const UIContext = createContext()

// 각 Context는 필요한 컴포넌트에만 제공
function App() {
  return (
    <UserContext.Provider value={userValue}>
      <UIContext.Provider value={uiValue}>
        <PostsContext.Provider value={postsValue}>
          <MainContent />
        </PostsContext.Provider>
      </UIContext.Provider>
    </UserContext.Provider>
  )
}
```

## 7. 번들 크기 최적화

```js
// webpack-bundle-analyzer로 번들 분석
npm install --save-dev webpack-bundle-analyzer

// package.json
{
  "scripts": {
    "analyze": "npm run build && npx webpack-bundle-analyzer build/static/js/*.js"
  }
}

// ✅ 트리 쉐이킹 활용
// 전체 라이브러리 import 피하기
import { debounce } from 'lodash'  // ❌
import debounce from 'lodash/debounce'  // ✅

// ✅ 동적 import로 필요할 때만 로드
const handleChartView = async () => {
  const { Chart } = await import('chart.js')
  // 차트 로직
}
```

<Warning>
성능 최적화는 측정 후 진행하세요. React DevTools Profiler나 Chrome DevTools를 사용해 실제 병목 지점을 파악한 후 최적화하는 것이 효율적입니다.
</Warning>

## 8. 효과적인 키 사용

```jsx
const TodoList = ({ todos, onToggle }) => {
  return (
    <ul>
      {todos.map((todo, index) => (
        // ❌ 배열 인덱스를 key로 사용
        // 항목 순서가 바뀌면 불필요한 리렌더링 발생
        <TodoItem 
          key={index}
          todo={todo} 
          onToggle={onToggle} 
        />
      ))}
    </ul>
  )
}

const TodoList = ({ todos, onToggle }) => {
  return (
    <ul>
      {todos.map(todo => (
        // ✅ 고유한 ID를 key로 사용
        <TodoItem 
          key={todo.id}
          todo={todo} 
          onToggle={onToggle} 
        />
      ))}
    </ul>
  )
}
```

## 9. 디바운싱과 쓰로틀링

```jsx
import { useMemo } from 'react'
import { debounce } from 'lodash'

const SearchInput = ({ onSearch }) => {
  // ✅ 검색 입력을 디바운싱
  const debouncedSearch = useMemo(
    () => debounce((query) => onSearch(query), 300),
    [onSearch]
  )

  const handleChange = (e) => {
    debouncedSearch(e.target.value)
  }

  return (
    <input 
      type="text"
      onChange={handleChange}
      placeholder="검색..."
    />
  )
}

// 스크롤 이벤트 쓰로틀링
const useScrollThrottle = (callback, delay) => {
  const throttledCallback = useMemo(
    () => throttle(callback, delay),
    [callback, delay]
  )

  useEffect(() => {
    window.addEventListener('scroll', throttledCallback)
    return () => window.removeEventListener('scroll', throttledCallback)
  }, [throttledCallback])
}
```

## 10. 성능 측정하기

```jsx
import { Profiler } from 'react'

const App = () => {
  const onRenderCallback = (id, phase, actualDuration) => {
    console.log('컴포넌트:', id)
    console.log('단계:', phase) // mount 또는 update
    console.log('렌더링 시간:', actualDuration, 'ms')
  }

  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <MainComponent />
    </Profiler>
  )
}

// Web Vitals 측정
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals'

getCLS(console.log)
getFID(console.log) 
getFCP(console.log)
getLCP(console.log)
getTTFB(console.log)
```

## 마무리

React 성능 최적화는 **측정 → 분석 → 최적화 → 재측정**의 사이클입니다. 

무작정 모든 것을 최적화하려 하지 말고, 실제 성능 문제가 있는 부분을 정확히 파악한 후 적절한 기법을 적용하세요. 

때로는 과도한 최적화가 코드 복잡성을 높여 오히려 개발 생산성을 떨어뜨릴 수 있습니다. 적절한 균형을 찾는 것이 중요합니다!
