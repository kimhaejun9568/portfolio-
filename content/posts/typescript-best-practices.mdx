---
title: "TypeScript 실무 베스트 프랙티스"
date: "2024-01-08"
description: "실제 프로젝트에서 TypeScript를 효과적으로 활용하기 위한 베스트 프랙티스와 팁들을 소개합니다."
tags: ["TypeScript", "JavaScript", "Best Practices"]
cover: "/images/posts/typescript-best-practices.jpg"
draft: false
---

TypeScript를 사용한 지 5년이 넘어가면서, 실무에서 정말 유용했던 패턴들과 피해야 할 안티패턴들을 정리해보고자 합니다.

## 타입 정의 전략

### 1. 인터페이스 vs 타입 별칭

언제 `interface`를 쓰고 언제 `type`을 써야 할까요?

```typescript
// ✅ 객체 형태는 interface 사용
interface User {
  id: number
  name: string
  email: string
}

// ✅ 확장 가능한 설계
interface AdminUser extends User {
  permissions: string[]
}

// ✅ 유니온, 기본 타입 등은 type 사용
type Status = 'loading' | 'success' | 'error'
type ID = string | number
```

### 2. 제네릭 활용

```typescript
// ✅ API 응답 타입을 제네릭으로 정의
interface ApiResponse<T> {
  data: T
  status: number
  message: string
}

// 사용 예시
type UserResponse = ApiResponse<User>
type UsersResponse = ApiResponse<User[]>

// ✅ 유틸리티 타입 직접 구현
type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>

// 사용: name을 선택적으로 만들기
type CreateUser = Optional<User, 'id'>
```

## 스마트한 타입 가드

```typescript
// ✅ 타입 가드 함수
function isString(value: unknown): value is string {
  return typeof value === 'string'
}

// ✅ 브랜드 타입으로 더 안전한 ID 관리
type UserId = string & { __brand: 'UserId' }
type PostId = string & { __brand: 'PostId' }

function createUserId(id: string): UserId {
  return id as UserId
}

// ❌ 이렇게 하면 실수할 수 있음
// function getUser(userId: string) { ... }
// function getPost(postId: string) { ... }

// ✅ 브랜드 타입으로 실수 방지
function getUser(userId: UserId) { ... }
function getPost(postId: PostId) { ... }
```

<Note>
브랜드 타입은 런타임에는 영향을 주지 않지만, 컴파일 타임에 타입 안전성을 크게 향상시킵니다.
</Note>

## 조건부 타입 활용

```typescript
// ✅ 함수 오버로드 대신 조건부 타입
type ApiCall<T extends 'user' | 'post'> = 
  T extends 'user' ? Promise<User> : Promise<Post>

async function fetchData<T extends 'user' | 'post'>(
  type: T
): ApiCall<T> {
  const response = await fetch(`/api/${type}`)
  return response.json()
}

// 타입이 자동으로 추론됨
const user = await fetchData('user')     // Promise<User>
const post = await fetchData('post')     // Promise<Post>
```

## 에러 처리 패턴

```typescript
// ✅ Result 패턴으로 안전한 에러 처리
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E }

async function safeApiCall<T>(
  fn: () => Promise<T>
): Promise<Result<T>> {
  try {
    const data = await fn()
    return { success: true, data }
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error : new Error('Unknown error')
    }
  }
}

// 사용법
const result = await safeApiCall(() => fetchUser(userId))

if (result.success) {
  // result.data는 User 타입
  console.log(result.data.name)
} else {
  // result.error는 Error 타입
  console.error(result.error.message)
}
```

## 컴포넌트 Props 타입 정의

React를 사용할 때 유용한 패턴들:

```typescript
// ✅ 기본 HTML 속성 확장
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger'
  loading?: boolean
}

const Button: React.FC<ButtonProps> = ({ 
  variant = 'primary', 
  loading, 
  children, 
  ...rest 
}) => {
  return (
    <button 
      className={`btn btn-${variant}`}
      disabled={loading}
      {...rest}
    >
      {loading ? 'Loading...' : children}
    </button>
  )
}

// ✅ 조건부 props
type ConditionalProps<T> = T extends true 
  ? { required: string } 
  : { optional?: string }

interface FormFieldProps<T extends boolean = false> extends ConditionalProps<T> {
  label: string
  required?: T
}

// required가 true면 required prop이 필수
<FormField label="Email" required={true} required="이메일을 입력하세요" />
```

## 환경 변수 타입 정의

```typescript
// env.d.ts
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      NODE_ENV: 'development' | 'production' | 'test'
      DATABASE_URL: string
      API_KEY: string
      PORT?: string
    }
  }
}

export {}

// 사용할 때 자동완성과 타입 검사
const dbUrl = process.env.DATABASE_URL // string
const port = process.env.PORT // string | undefined
```

## 유틸리티 타입 활용

```typescript
// ✅ 기존 타입에서 새로운 타입 파생
type CreateUserRequest = Omit<User, 'id' | 'createdAt'>
type UpdateUserRequest = Partial<Pick<User, 'name' | 'email'>>

// ✅ 키를 기반으로 한 타입 생성
const USER_STATUS = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  PENDING: 'pending',
} as const

type UserStatus = typeof USER_STATUS[keyof typeof USER_STATUS] // 'active' | 'inactive' | 'pending'

// ✅ 함수 시그니처에서 타입 추출
function processUser(user: User): Promise<ProcessResult> {
  // ...
}

type ProcessUserParams = Parameters<typeof processUser>[0] // User
type ProcessUserReturn = ReturnType<typeof processUser>    // Promise<ProcessResult>
```

<Warning>
`any` 타입은 피하고, 정말 어쩔 수 없는 경우에는 `unknown`을 사용하세요.
</Warning>

## 성능 최적화

```typescript
// ✅ 타입 연산 최적화
// 깊은 중첩 타입은 성능에 영향을 줄 수 있음
type DeepNested = {
  level1: {
    level2: {
      level3: {
        value: string
      }
    }
  }
}

// 대신 인터페이스 분리
interface Level3 {
  value: string
}

interface Level2 {
  level3: Level3
}

interface Level1 {
  level2: Level2
}

interface DeepNestedOptimized {
  level1: Level1
}
```

## tsconfig.json 설정

```json
{
  "compilerOptions": {
    "strict": true,                    // 모든 엄격한 검사 활성화
    "noUncheckedIndexedAccess": true,  // 인덱스 접근 시 undefined 체크
    "exactOptionalPropertyTypes": true, // 선택적 프로퍼티 엄격 검사
    "noImplicitReturns": true,         // 모든 경로에서 반환값 체크
    "noFallthroughCasesInSwitch": true, // switch문 fallthrough 방지
    "noImplicitOverride": true,        // 명시적 override 키워드 필요
    "useUnknownInCatchVariables": true // catch의 error를 unknown으로
  }
}
```

## 마무리

TypeScript는 단순한 타입 어노테이션 도구가 아닙니다. 잘 활용하면 런타임 에러를 크게 줄이고, 코드의 의도를 명확히 표현할 수 있습니다.

중요한 것은 **점진적으로 도입**하는 것입니다. 처음부터 완벽한 타입을 정의하려 하지 말고, 프로젝트가 성장하면서 타입도 함께 개선해 나가세요.

다음에는 TypeScript와 React를 함께 사용할 때의 고급 패턴들을 다뤄보겠습니다!
